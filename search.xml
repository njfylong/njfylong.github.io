<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android启动过程-init]]></title>
      <url>%2F2017%2F05%2F07%2FAndroid%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-init%2F</url>
      <content type="text"><![CDATA[Android是基于Linux基础上开发的OS，其内核还是Linux，所以Android系统的启动可以看成：Linux -&gt; Android，本文仅介绍Android的启动过程。 init启动过程Linux Kernel启动完成后，转而进入Android的启动，即由内核层转向用户层。init是Linux Kernel完成后进入用户空间的第一个进程，后面的进程在该进程上fork出来的。 AIL(Android Init Language)在init中，会涉及到很多的AIL（Android Init Language）也就是.rc文件，如init.rc、init.environ.rc、init.usb.rc、init.${ro.hardware}.rc、init.${ro.zygote}.rc等。AIL中主要做一些启动和属性相关的配置。 AIL包括四中类型：Actions、Command、Services、Options ActionsActions格式：1234on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]* &lt;command&gt; &lt;command&gt; &lt;command&gt; trigger是一个触发器，当系统匹配该触发器的事件发生时，将会执行command中命令。常见的command有：bootchart_init、chmod、chown等。(更多command可参考./system/core/init/readme.txt) ServicesServices是系统启动具体是init开始是需要启动的service，这里的service跟后面我们要说的各种service不是一个概念。Service格式如下：1234service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]* &lt;option&gt; &lt;option&gt; ... service中的option有：critical：在四分中内重启超过四次，系统重启进入recovery模式disabled：不能自动启动setenv：设置service环境变量socket：创建socketuser：执行服务前更改用户名group：执行服务前更改用户组seclabel：执行服务前更改安全级别oneshot：退出时不重启服务class：指定服务类，相同类名的服务可以同时启动或停止，模式为defaultonrestart：当服务重新启动时执行一个命令writepid：创建进程时将子进程号写入文件 Imports这里的import不是一个command init基本流程init的入口main函数在system/core/init/init.cpp中，1234567if (!strcmp(basename(argv[0]), &quot;ueventd&quot;)) &#123; return ueventd_main(argc, argv);&#125;if (!strcmp(basename(argv[0]), &quot;watchdogd&quot;)) &#123; return watchdogd_main(argc, argv);&#125; 根据传入参数，启动ueventd、watchdogd。这里的ueventd_main、watchdogd_main两个函数可以看成是ueventd、watchdogd的入口函数，它们完全可以独立写成和init的模块，之所以没有这么做是因为跟init共享的东西太多。这里把ueventd、watchdogd做成init的软链接,system/core/init/Android.mk:1234# Create symlinksLOCAL_POST_INSTALL_CMD := $(hide) mkdir -p $(TARGET_ROOT_OUT)/sbin; \ ln -sf ../init $(TARGET_ROOT_OUT)/sbin/ueventd; \ ln -sf ../init $(TARGET_ROOT_OUT)/sbin/watchdogd 12// Clear the umask.umask(0); 这里主要mask文件权限。 12345678910111213141516// 添加环境add_environment(&quot;PATH&quot;, _PATH_DEFPATH);bool is_first_stage = (argc == 1) || (strcmp(argv[1], &quot;--second-stage&quot;) != 0);// Get the basic filesystem setup we need put together in the initramdisk// on / and then we&apos;ll let the rc file figure out the rest.if (is_first_stage) &#123; mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;); mkdir(&quot;/dev/pts&quot;, 0755); mkdir(&quot;/dev/socket&quot;, 0755); mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL); #define MAKE_STR(x) __STRING(x) mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC)); mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL);&#125; 创建tmpfs、/dev/pts、/dev/socket、devpts等节点并挂载。 1234567// We must have some place other than / to create the device nodes for// kmsg and null, otherwise we won&apos;t be able to remount / read-only// later on. Now that tmpfs is mounted on /dev, we can actually talk// to the outside world.open_devnull_stdio();klog_init();klog_set_level(KLOG_NOTICE_LEVEL); open_devnull_stdio：实现在system/core/init/Util.cpp中。klog_init：初始化kernel log，可以用于init过程的调试klog_set_level：设置kernel log的级别，默认的是KLOG_NOTICE_LEVEL，定义的级别有：12345#define KLOG_ERROR_LEVEL 3#define KLOG_WARNING_LEVEL 4#define KLOG_NOTICE_LEVEL 5#define KLOG_INFO_LEVEL 6#define KLOG_DEBUG_LEVEL 7 12// Indicate that booting is in progress to background fw loaders, etc.close(open(&quot;/dev/.booting&quot;, O_WRONLY | O_CREAT | O_CLOEXEC, 0000)); 创建/dev/.booting，加载fimware的时候用。 12345678910property_init();// If arguments are passed both on the command line and in DT,// properties set in DT always have priority over the command-line ones.process_kernel_dt();process_kernel_cmdline();// Propagate the kernel variables to internal variables// used by init as well as the current required properties.export_kernel_boot_props(); 初始化属性和导入kernel启动属性，主要有：ro.boot.serialno、ro.boot.mode、ro.boot.baseband、ro.boot.bootloader、ro.boot.hardware、ro.boot.revision。 12// Set up SELinux, including loading the SELinux policy if we&apos;re in the kernel domain.selinux_initialize(is_first_stage); 初始化selinux。 1property_load_boot_defaults(); 加载property，这里主要是build.prop、system.prop、default.prop。 12345Parser&amp; parser = Parser::GetInstance();parser.AddSectionParser(&quot;service&quot;,std::make_unique&lt;ServiceParser&gt;());parser.AddSectionParser(&quot;on&quot;, std::make_unique&lt;ActionParser&gt;());parser.AddSectionParser(&quot;import&quot;, std::make_unique&lt;ImportParser&gt;());parser.ParseConfig(&quot;/init.rc&quot;); 载入init.rc，并设置section:service、on、import，*.rc参考AIL。跟Android N之前的版本相比，这块的实现有变化。Android N之前，action、command、service都是通过结构体实现，Android N中把它们提出来分别定义成类。 1234567891011121314151617181920212223242526272829ActionManager&amp; am = ActionManager::GetInstance();am.QueueEventTrigger(&quot;early-init&quot;);// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...am.QueueBuiltinAction(wait_for_coldboot_done_action, &quot;wait_for_coldboot_done&quot;);// ... so that we can start queuing up actions that require stuff from /dev.am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;);am.QueueBuiltinAction(set_mmap_rnd_bits_action, &quot;set_mmap_rnd_bits&quot;);am.QueueBuiltinAction(keychord_init_action, &quot;keychord_init&quot;);am.QueueBuiltinAction(console_init_action, &quot;console_init&quot;);// Trigger all the boot actions to get us started.am.QueueEventTrigger(&quot;init&quot;);// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random// wasn&apos;t ready immediately after wait_for_coldboot_doneam.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;);// Don&apos;t mount filesystems or start core system services in charger mode.std::string bootmode = property_get(&quot;ro.bootmode&quot;);if (bootmode == &quot;charger&quot;) &#123; am.QueueEventTrigger(&quot;charger&quot;);&#125; else &#123; am.QueueEventTrigger(&quot;late-init&quot;);&#125;// Run all property triggers based on current state of the properties.am.QueueBuiltinAction(queue_property_triggers_action, &quot;queue_property_triggers&quot;); 将early-init,init置于相应的EventTrigger queue中．同时添加内置的action：mix_hwrng_into_linux_rng_action，set_mmap_rnd_bits_action，keychord_init_action，console_init_action，mix_hwrng_into_linux_rng_action等． 最后，init中最终要的是看懂AIL,rc脚本中包含基本的启动任务．]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工具－opengrok搭建]]></title>
      <url>%2F2017%2F03%2F18%2Fopengrok-building%2F</url>
      <content type="text"><![CDATA[OpenGork是一个快速、便于使用的源码搜索引d擎与对照引擎，能帮我们快速的搜索、定位、对照代码树。 下载Tomcat,OpenGorkapache-tomcat-7.0.22.tar.gz：https://pan.baidu.com/s/1geHdfAbopengrok-0.12.1.tar.gz：https://pan.baidu.com/s/1o7EgW4M 启动Tomact12cd Tomact/bin./startup.sh 配置OpenGork解压opengrok将opengrok-0.12.1/lib目录下的source.war包拷贝到apache-tomcat-7.0.40/webapps目录下，在浏览器中输入 http://localhost:8080/source/ 查看是否配置成功。 创建/var/opengrok/etc/目录12345cd /varsudo mkdir opengroksudo mkdir opengrok/etcsudo chmod -R 777 opengroksudo chown archermind:archermind opengrok 建立源码索引12cd opengrok-0.11.1/bin./OpenGrok index /data/code 访问http://localhost:8080/source/ 查看。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hello-world]]></title>
      <url>%2F2017%2F03%2F16%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
